# Proyecto de Base de Datos: Gestión de Atletas de MMA

Este proyecto consiste en el desarrollo de un sistema de base de datos en *Oracle 21c* para la gestión integral de atletas y eventos de Artes Marciales Mixtas (MMA). La solución utiliza DDL para la creación de la estructura y *PL/SQL (Procedimientos, Funciones, Packages y Triggers)* para implementar la lógica de negocio, la automatización de procesos y la auditoría de datos.

## Integrantes
* Gabriel Duran
* Claudio Salcedo

## Descripción del Proyecto
El objetivo principal es automatizar el registro, seguimiento y análisis de datos de peleadores y eventos para mejorar la toma de decisiones. Se ha creado un conjunto de procedimientos, funciones y triggers en PL/SQL que administran de forma eficiente la información deportiva y administrativa, garantizando la integridad, seguridad y escalabilidad del sistema.

## Modelo de la Base de Datos

### Diagrama Entidad-Relación
A continuación se presenta el modelo relacional que define la estructura de la base de datos y las relaciones entre las distintas entidades.



### Descripción de Tablas Clave
*   **PELEADOR**: Almacena los datos personales y el récord de los atletas (victorias, derrotas, empates).
*   **EVENTO**: Registra la información de los torneos, como nombre, fecha, lugar y datos comerciales.
*   **PELEA**: Contiene los detalles de cada combate, relacionando a dos peleadores y un evento.
*   **CATEGORIA_PESO**: Define las distintas categorías de peso del deporte.
*   **ESTILO_COMBATE**: Catálogo de los diferentes estilos de lucha (Jiu-Jitsu, Boxeo, etc.).
*   **PELEADOR_ESTILO**: Tabla intermedia que gestiona la relación N:M entre peleadores y sus estilos de combate.
*   **RANKING_LIBRA_LIBRA** y **RANKING_CATEGORIA**: Gestionan las clasificaciones y rankings de los peleadores.
*   **PELEADOR_AUDITORIA** y **EVENTO_AUDITORIA**: Tablas de historial que registran automáticamente los cambios (UPDATES) o eliminaciones (DELETES) en las tablas PELEADOR y EVENTO, gracias al uso de Triggers.

## Características Implementadas con PL/SQL

El sistema va más allá del simple almacenamiento de datos, implementando lógica avanzada a través de:

1.  *Procedimientos Almacenados*:
    *   *Con Parámetros*: Para ejecutar tareas específicas como la actualización del récord de un peleador (p_record_peleador_vic).
    *   *Sin Parámetros*: Para generar reportes generales, como un listado de todos los eventos (reporte_eventos).
    *   *Beneficios*: Reutilización de código, mantenimiento centralizado, mayor seguridad y mejor rendimiento.

2.  *Funciones Almacenadas*:
    *   Diseñadas para encapsular cálculos y devolver un único valor. Por ejemplo, una función f_total_combates que calcula el número total de peleas de un atleta.
    *   *Beneficios*: Se integran directamente en sentencias SELECT, simplifican la lógica y permiten construir librerías de cálculos reutilizables.

3.  *Packages*:
    *   Se implementó el package procedimientos_peleador para agrupar toda la lógica relacionada con las estadísticas de los peleadores.
    *   *Estructura*:
        *   *Especificación (Pública)*: Declara los procedimientos que pueden ser llamados desde fuera (ej: estadisticas_resultado).
        *   *Cuerpo (Privado)*: Contiene la implementación del código y procedimientos privados (ej: calcular_porcentajes), ocultando la complejidad interna.
    *   *Beneficios*: Modularidad, encapsulación, mejor rendimiento al cargar en memoria y escalabilidad.

4.  *Triggers*:
    *   Se creó el trigger trg_auditoria_peleador que se dispara automáticamente después de un UPDATE o DELETE en la tabla PELEADOR.
    *   *Funcionalidad: Guarda una copia de los datos *antes del cambio en la tabla PELEADOR_AUDITORIA, creando un historial de cambios infalible.
    *   *Beneficios*: Auditoría automática, garantía de integridad de datos y automatización de procesos en cadena.

## Código de Creación de la Base de Datos (DDL)

El siguiente script SQL contiene todas las sentencias CREATE TABLE y ALTER TABLE utilizadas para construir la estructura de la base de datos del proyecto.

sql
-- Tabla de categorías de peso (ej: Lightweight, Welterweight, etc.)
CREATE TABLE categoria_peso (
    id_categoria    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre          VARCHAR2(50) NOT NULL,
    limite_inferior NUMBER(5,2), -- en kg
    limite_superior NUMBER(5,2)  -- en kg
);

-- Tabla de estilos de combate (ej: Jiu-Jitsu, Muay Thai, Wrestling)
CREATE TABLE estilo_combate (
    id_estilo   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre      VARCHAR2(50) NOT NULL UNIQUE
);

-- Tabla de peleadores
CREATE TABLE peleador (
    id_peleador     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre          VARCHAR2(100) NOT NULL,
    apodo           VARCHAR2(50),
    edad            NUMBER(3),
    nacionalidad    VARCHAR2(50),
    id_categoria    NUMBER NOT NULL,
    victorias       NUMBER DEFAULT 0,
    derrotas        NUMBER DEFAULT 0,
    empates         NUMBER DEFAULT 0,
    CHECK (victorias >= 0 AND derrotas >= 0 AND empates >= 0),
    CONSTRAINT fk_categoria FOREIGN KEY (id_categoria)
        REFERENCES categoria_peso(id_categoria)
);

-- Relación N:M entre peleadores y estilos de combate
CREATE TABLE peleador_estilo (
    id_peleador NUMBER NOT NULL,
    id_estilo   NUMBER NOT NULL,
    PRIMARY KEY (id_peleador, id_estilo),
    CONSTRAINT fk_pelea_estilo_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_estilo_estilo FOREIGN KEY (id_estilo)
        REFERENCES estilo_combate(id_estilo)
);

-- Tabla de eventos (ej: UFC 300, Fight Night, etc.)
CREATE TABLE evento (
    id_evento   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre      VARCHAR2(100) NOT NULL,
    fecha       DATE NOT NULL,
    lugar       VARCHAR2(100)
);

-- Tabla de peleas (cada evento tiene varias peleas)
CREATE TABLE pelea (
    id_pelea       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_evento      NUMBER NOT NULL,
    id_peleador1   NUMBER NOT NULL,
    id_peleador2   NUMBER NOT NULL,
    resultado      VARCHAR2(50), -- Ej: "KO", "Sumisión", "Decisión"
    ganador        NUMBER,       -- ID del peleador ganador
    CONSTRAINT fk_pelea_evento FOREIGN KEY (id_evento)
        REFERENCES evento(id_evento),
    CONSTRAINT fk_pelea_peleador1 FOREIGN KEY (id_peleador1)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_peleador2 FOREIGN KEY (id_peleador2)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_ganador FOREIGN KEY (ganador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT chk_pelea_distintos CHECK (id_peleador1 <> id_peleador2)
);

-- Tabla de ranking libra por libra
CREATE TABLE ranking_libra_libra (
    id_ranking   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_peleador  NUMBER NOT NULL,
    posicion     NUMBER NOT NULL,
    fecha        DATE DEFAULT SYSDATE,
    CONSTRAINT fk_ranking_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT uq_ranking UNIQUE (posicion, fecha) -- cada posición única en cada fecha
);


-- Ranking por categoría de peso (ej: Top 15 en cada división)
CREATE TABLE ranking_categoria (
    id_ranking     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_categoria   NUMBER NOT NULL,
    id_peleador    NUMBER NOT NULL,
    posicion       NUMBER NOT NULL, -- 1 al 15
    fecha          DATE DEFAULT SYSDATE,
    CONSTRAINT fk_rankcat_categoria FOREIGN KEY (id_categoria)
        REFERENCES categoria_peso(id_categoria),
    CONSTRAINT fk_rankcat_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT uq_rankcat UNIQUE (id_categoria, posicion, fecha),
    CONSTRAINT chk_rankcat_pos CHECK (posicion BETWEEN 1 AND 15)
);


--Tabla para guardar filas antiguas después de un update o delete en PELEADOR
CREATE TABLE peleador_auditoria (
    id_auditoria      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_peleador       NUMBER,
    nombre            VARCHAR2(100),
    apodo             VARCHAR2(50),
    edad              NUMBER(3),
    nacionalidad      VARCHAR2(50),
    id_categoria      NUMBER,
    victorias         NUMBER,
    derrotas          NUMBER,
    empates           NUMBER,
    fecha_auditoria   DATE DEFAULT SYSDATE,
    tipo_modificacion VARCHAR2(20) DEFAULT 'sin especificar'
);

--Tabla para guardar filas antiguas después de un update o delete en EVENTO
CREATE TABLE evento_auditoria (
    id_auditoria      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_evento         NUMBER,
    nombre            VARCHAR2(100),
    fecha             DATE,
    lugar             VARCHAR2(100),
    entradas_vendidas NUMBER(7),
    precio_entrada    NUMBER(5),
    fecha_auditoria   DATE DEFAULT SYSDATE,
    tipo_modificacion VARCHAR2(20) DEFAULT 'sin especificar'
);


-- Cambios en las tablas para añadir nuevos campos
ALTER TABLE evento
ADD (
    entradas_vendidas NUMBER(7),
    precio_entrada    NUMBER(5)
);


## Cómo Empezar

Para desplegar este proyecto, sigue los siguientes pasos:

1.  *Prerrequisitos: Tener acceso a una instancia de **Oracle Database* (versión 12c o superior recomendada).
2.  *Conexión*: Conéctate a la base de datos usando un cliente SQL como SQL Developer.
3.  *Ejecución del Script*: Ejecuta el script DDL proporcionado en la sección anterior para crear todas las tablas y sus relaciones.
4.  *Despliegue de PL/SQL*: Ejecuta los scripts correspondientes a los procedimientos, funciones, packages y triggers del proyecto.
5.  *Población de Datos (Opcional)*: Inserta datos de prueba en las tablas para verificar el funcionamiento de los componentes.

# Version no SQL 

En la carpeta no sql se tiene todos los archivos para poder hacer un copia y pega atravez de mongoDump para poder pusarlo en su mongo db

## Cómo Empezar (NOsql)

Para desplegar este proyecto, sigue los siguientes pasos:

1.  *Prerrequisitos: Tener instalado MongoDb, mondoDevTools, MongoDump y MongoShell.
2.  *Conexión*: Conéctate a la base de datos usando atravez de un cliente de preferencia.
3.  *Restauracion con mongoDump*: Con mongoDump insertar la copia de datos a su base de datos de preferencia.



