# Proyecto de Base de Datos: Gestión de Atletas de MMA

Este proyecto consiste en el desarrollo de un sistema de base de datos en **Oracle 21c** para la gestión integral de atletas y eventos de Artes Marciales Mixtas (MMA). La solución utiliza DDL para la creación de la estructura y **PL/SQL (Procedimientos, Funciones, Packages y Triggers)** para implementar la lógica de negocio, la automatización de procesos y la auditoría de datos.

## Integrantes
* Gabriel Duran
* Claudio Salcedo

## Descripción del Proyecto
El objetivo principal es automatizar el registro, seguimiento y análisis de datos de peleadores y eventos para mejorar la toma de decisiones. Se ha creado un conjunto de procedimientos, funciones y triggers en PL/SQL que administran de forma eficiente la información deportiva y administrativa, garantizando la integridad, seguridad y escalabilidad del sistema.

## Modelo de la Base de Datos

### Diagrama Entidad-Relación
A continuación se presenta el modelo relacional que define la estructura de la base de datos y las relaciones entre las distintas entidades.



### Descripción de Tablas Clave
*   **`PELEADOR`**: Almacena los datos personales y el récord de los atletas (victorias, derrotas, empates).
*   **`EVENTO`**: Registra la información de los torneos, como nombre, fecha, lugar y datos comerciales.
*   **`PELEA`**: Contiene los detalles de cada combate, relacionando a dos peleadores y un evento.
*   **`CATEGORIA_PESO`**: Define las distintas categorías de peso del deporte.
*   **`ESTILO_COMBATE`**: Catálogo de los diferentes estilos de lucha (Jiu-Jitsu, Boxeo, etc.).
*   **`PELEADOR_ESTILO`**: Tabla intermedia que gestiona la relación N:M entre peleadores y sus estilos de combate.
*   **`RANKING_LIBRA_LIBRA`** y **`RANKING_CATEGORIA`**: Gestionan las clasificaciones y rankings de los peleadores.
*   **`PELEADOR_AUDITORIA`** y **`EVENTO_AUDITORIA`**: Tablas de historial que registran automáticamente los cambios (UPDATES) o eliminaciones (DELETES) en las tablas `PELEADOR` y `EVENTO`, gracias al uso de Triggers.

## Características Implementadas con PL/SQL

El sistema va más allá del simple almacenamiento de datos, implementando lógica avanzada a través de:

1.  **Procedimientos Almacenados**:
    *   **Con Parámetros**: Para ejecutar tareas específicas como la actualización del récord de un peleador (`p_record_peleador_vic`).
    *   **Sin Parámetros**: Para generar reportes generales, como un listado de todos los eventos (`reporte_eventos`).
    *   **Beneficios**: Reutilización de código, mantenimiento centralizado, mayor seguridad y mejor rendimiento.

2.  **Funciones Almacenadas**:
    *   Diseñadas para encapsular cálculos y devolver un único valor. Por ejemplo, una función `f_total_combates` que calcula el número total de peleas de un atleta.
    *   **Beneficios**: Se integran directamente en sentencias `SELECT`, simplifican la lógica y permiten construir librerías de cálculos reutilizables.

3.  **Packages**:
    *   Se implementó el package `procedimientos_peleador` para agrupar toda la lógica relacionada con las estadísticas de los peleadores.
    *   **Estructura**:
        *   **Especificación (Pública)**: Declara los procedimientos que pueden ser llamados desde fuera (ej: `estadisticas_resultado`).
        *   **Cuerpo (Privado)**: Contiene la implementación del código y procedimientos privados (ej: `calcular_porcentajes`), ocultando la complejidad interna.
    *   **Beneficios**: Modularidad, encapsulación, mejor rendimiento al cargar en memoria y escalabilidad.

4.  **Triggers**:
    *   Se creó el trigger `trg_auditoria_peleador` que se dispara automáticamente después de un `UPDATE` o `DELETE` en la tabla `PELEADOR`.
    *   **Funcionalidad**: Guarda una copia de los datos *antes* del cambio en la tabla `PELEADOR_AUDITORIA`, creando un historial de cambios infalible.
    *   **Beneficios**: Auditoría automática, garantía de integridad de datos y automatización de procesos en cadena.

## Código de Creación de la Base de Datos (DDL)

El siguiente script SQL contiene todas las sentencias `CREATE TABLE` y `ALTER TABLE` utilizadas para construir la estructura de la base de datos del proyecto.

```sql
-- Tabla de categorías de peso (ej: Lightweight, Welterweight, etc.)
CREATE TABLE categoria_peso (
    id_categoria    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre          VARCHAR2(50) NOT NULL,
    limite_inferior NUMBER(5,2), -- en kg
    limite_superior NUMBER(5,2)  -- en kg
);

-- Tabla de estilos de combate (ej: Jiu-Jitsu, Muay Thai, Wrestling)
CREATE TABLE estilo_combate (
    id_estilo   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre      VARCHAR2(50) NOT NULL UNIQUE
);

-- Tabla de peleadores
CREATE TABLE peleador (
    id_peleador     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre          VARCHAR2(100) NOT NULL,
    apodo           VARCHAR2(50),
    edad            NUMBER(3),
    nacionalidad    VARCHAR2(50),
    id_categoria    NUMBER NOT NULL,
    victorias       NUMBER DEFAULT 0,
    derrotas        NUMBER DEFAULT 0,
    empates         NUMBER DEFAULT 0,
    CHECK (victorias >= 0 AND derrotas >= 0 AND empates >= 0),
    CONSTRAINT fk_categoria FOREIGN KEY (id_categoria)
        REFERENCES categoria_peso(id_categoria)
);

-- Relación N:M entre peleadores y estilos de combate
CREATE TABLE peleador_estilo (
    id_peleador NUMBER NOT NULL,
    id_estilo   NUMBER NOT NULL,
    PRIMARY KEY (id_peleador, id_estilo),
    CONSTRAINT fk_pelea_estilo_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_estilo_estilo FOREIGN KEY (id_estilo)
        REFERENCES estilo_combate(id_estilo)
);

-- Tabla de eventos (ej: UFC 300, Fight Night, etc.)
CREATE TABLE evento (
    id_evento   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre      VARCHAR2(100) NOT NULL,
    fecha       DATE NOT NULL,
    lugar       VARCHAR2(100)
);

-- Tabla de peleas (cada evento tiene varias peleas)
CREATE TABLE pelea (
    id_pelea       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_evento      NUMBER NOT NULL,
    id_peleador1   NUMBER NOT NULL,
    id_peleador2   NUMBER NOT NULL,
    resultado      VARCHAR2(50), -- Ej: "KO", "Sumisión", "Decisión"
    ganador        NUMBER,       -- ID del peleador ganador
    CONSTRAINT fk_pelea_evento FOREIGN KEY (id_evento)
        REFERENCES evento(id_evento),
    CONSTRAINT fk_pelea_peleador1 FOREIGN KEY (id_peleador1)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_peleador2 FOREIGN KEY (id_peleador2)
        REFERENCES peleador(id_peleador),
    CONSTRAINT fk_pelea_ganador FOREIGN KEY (ganador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT chk_pelea_distintos CHECK (id_peleador1 <> id_peleador2)
);

-- Tabla de ranking libra por libra
CREATE TABLE ranking_libra_libra (
    id_ranking   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_peleador  NUMBER NOT NULL,
    posicion     NUMBER NOT NULL,
    fecha        DATE DEFAULT SYSDATE,
    CONSTRAINT fk_ranking_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT uq_ranking UNIQUE (posicion, fecha) -- cada posición única en cada fecha
);


-- Ranking por categoría de peso (ej: Top 15 en cada división)
CREATE TABLE ranking_categoria (
    id_ranking     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_categoria   NUMBER NOT NULL,
    id_peleador    NUMBER NOT NULL,
    posicion       NUMBER NOT NULL, -- 1 al 15
    fecha          DATE DEFAULT SYSDATE,
    CONSTRAINT fk_rankcat_categoria FOREIGN KEY (id_categoria)
        REFERENCES categoria_peso(id_categoria),
    CONSTRAINT fk_rankcat_peleador FOREIGN KEY (id_peleador)
        REFERENCES peleador(id_peleador),
    CONSTRAINT uq_rankcat UNIQUE (id_categoria, posicion, fecha),
    CONSTRAINT chk_rankcat_pos CHECK (posicion BETWEEN 1 AND 15)
);


--Tabla para guardar filas antiguas después de un update o delete en PELEADOR
CREATE TABLE peleador_auditoria (
    id_auditoria      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_peleador       NUMBER,
    nombre            VARCHAR2(100),
    apodo             VARCHAR2(50),
    edad              NUMBER(3),
    nacionalidad      VARCHAR2(50),
    id_categoria      NUMBER,
    victorias         NUMBER,
    derrotas          NUMBER,
    empates           NUMBER,
    fecha_auditoria   DATE DEFAULT SYSDATE,
    tipo_modificacion VARCHAR2(20) DEFAULT 'sin especificar'
);

--Tabla para guardar filas antiguas después de un update o delete en EVENTO
CREATE TABLE evento_auditoria (
    id_auditoria      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_evento         NUMBER,
    nombre            VARCHAR2(100),
    fecha             DATE,
    lugar             VARCHAR2(100),
    entradas_vendidas NUMBER(7),
    precio_entrada    NUMBER(5),
    fecha_auditoria   DATE DEFAULT SYSDATE,
    tipo_modificacion VARCHAR2(20) DEFAULT 'sin especificar'
);


-- Cambios en las tablas para añadir nuevos campos
ALTER TABLE evento
ADD (
    entradas_vendidas NUMBER(7),
    precio_entrada    NUMBER(5)
);
```

## Cómo Empezar

Para desplegar este proyecto, sigue los siguientes pasos:

1.  **Prerrequisitos**: Tener acceso a una instancia de **Oracle Database** (versión 12c o superior recomendada).
2.  **Conexión**: Conéctate a la base de datos usando un cliente SQL como SQL Developer.
3.  **Ejecución del Script**: Ejecuta el script DDL proporcionado en la sección anterior para crear todas las tablas y sus relaciones.
4.  **Despliegue de PL/SQL**: Ejecuta los scripts correspondientes a los procedimientos, funciones, packages y triggers del proyecto.
5.  **Población de Datos (Opcional)**: Inserta datos de prueba en las tablas para verificar el funcionamiento de los componentes.
